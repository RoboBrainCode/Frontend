<div class="jumbotron">
<div class="container-fluid">
  

      <label style="float:left ">Try out:</label>
      <select class="form-control" id="sel2">
        <option>Fetch</option>
        <option>Sort</option>
        <option>Map</option>
        <option>Filter</option>
      </select>
    <button type="button" class="btn btn-link" onclick="myFunction()" style="font-size:14px; font-weight:bold; outline:0">Show</button>



  <textarea class="form-control" style="width: 100%; border:none; color:#009900; font-family: Courier; resize:none" rows="5" id="demo" ng-model="query.query" onkeypress="handle">//Enter Your Code</textarea>
  <div class="form-inline">
  <div class="form-group">   
  <button type="submit" class="btn btn-link" onclick="cleararea()" style="font-size:14px; font-weight:bold; outline:0; float:left">Clear</button></div>
  <div class="form-group">        
        <button type="submit" class="btn btn-link" ng-click="sendQuery(query)" style="font-size:14px; font-weight:bold; outline:0; float:right">Execute</button>    
    </div>
  </div>
     <div id="drope_box" style="display:none;">
      <br>
   <div id="regeStr" style="overflow-y:scroll;height:300px;text-wrap:unrestricted"> 

   </div>
</div>
</div>

  </div>



<div class="page-header">
    <h2 class="text-center">RaQuel <small>API Documentation v1.0</small></h1>
</div>

        <p>RaQueL is a query language, through which the robots use RoboBrain for various robotic applications. The RaQuel provides a rich set of retrieval functions and programming constructs to perform complex traversals on the RoboBrain graph. <br><br>
          RaQuel v1.0 can only support functions {u,e,v} with only one node variable 'v'. The node 'u' and edge 'e' cannot be assigned a variable. Nodes 'u' and 'v' can only support one attribute i.e. 'handle'. In addition,'Belief' is the only key supported for sorting tuples. <br>[*a..b] defines the length of the path and are called hops. {u,[e*a..b],v} finds path which can be a to b edges from 'u' node to 'v' node.<br><br>
          Currently, RaQuel supports the following functions:</p>
        
        <p class="fetch">1. <span style="font-family: Courier;">fetch</span> function</p>
        <div class="panel1">
        <p>
          <code>fetch: Pattern(arg<sub>1</sub>,arg<sub>2</sub>,...)</code> returns a list of tuples with instantiated values of variables <code>[(arg<sub>1</sub><sup>(i)</sup>,arg<sub>1</sub><sup>(i)</sup>,...)]<sub>i<sub></code>. 
          This pattern is matched against the RoboBrain graph and these matched sub-graphs are used to create initialized entries for the pattern variables.<br><br>
          For example, to retrieve all the objects which a 'standing human' can use:
        </p>
        <blockquote>
          >>> fetch("({handle:'standing_human'})-[:`CAN_USE`]->(v)")
        </blockquote>
        <p>
          The pattern will match against paths of length one {u, e, v}; where node
          u has handle 'standing_human' and edge e has label 'CAN_USE'.
        </p>
        </div>
        <p class="sort">2. <span style="font-family: Courier;">SortBy</span> function</p>
        <div class="panel2">
        <p><code>SortBy(Pattern,'key')</code> returns a list of tuples sorted according to the key. <br><br>
          For example, to find path which are 1 to 5 edges away from standing_human node to the phone node and then to rank these paths in ascending order by their beliefs:
        </p>
        <blockquote>
          >>> paths =fetch("({handle:'standing_human'})-[e*1..5]->({handle:'phone'})")
          <br> >>> SortBy(paths,'Belief')
        </blockquote>
        </div>
        <p class="map">3. <span style="font-family: Courier;">map</span> function</p>
        <div class="panel4">
        <p>The map function evaluates a lazy map on a list of nodes or relationships specified.<br><br>
        For example, to find objects which a 'sitting human' can use then map them to their affordances using lazy evaluations. This program iterates overs 2 elements in the objects list.
        </p>
        <blockquote>
          >>> global objects
          <br> >>> objects =fetch("({handle:'sitting_human'})-[:`CAN_USE`]->(V)")
          <br> >>> affordances=lambda n:fetch("({handle :'\" + n + \"'})-[:`HAS_AFFORDANCE`]->(v)")
          <br> >>> iter = imap( lambda u: (u) ,objects[1])
          <br> >>> print iter.next()
          <br> >>> print iter.next()
        </blockquote>
        </div>
        <p class="filter">4. <span style="font-family: Courier;">filter</span> function</p>
        <div class="panel5">
        <p>The filter function evaluates a lazy map on a list of nodes or relationships specified.<br><br>
          For example, to find a unique media represenation of 'tv'.</p>
          <blockquote>
          >>> global entities, media
          <br> >>> entities = lambda n: fetch("(v)-[:`HAS_MEDIA`]->({handle :'" + n + "'})")
          <br> >>> media = lambda n:fetch("({handle :'" + n + "'})-[:`HAS_MEDIA`]->(v)")
          <br> >>> ind_media = lambda a: ifilter(lambda u: len(entities(u)[1])==1,(media(a))[1])
          <br> >>> iter1= ind_media('tv')  
          <br> >>> print iter1.next()
        </blockquote>
        </div>


<br>



<script type="text/javascript">
function myFunction() {
    var x=document.getElementById("sel2").value;
    var y=x.split(" ")
    if(y[0]=="Fetch"){
    document.getElementById("demo").value="//Enter Your Code\n>>>fetch(\"({handle:'wall'})-[:`HAS_MATERIAL`]->(b)\")";
  }
    else if(y[0]=="Sort"){
    document.getElementById("demo").value="//Enter Your Code\n>>>path = fetch(\"(\{handle:'sitting_human'})-[e*1..3]->({handle:'cup'})\")\n>>>SortBy(\paths,'Belief')";
  }
    else if(y[0]=="Map"){
    document.getElementById("demo").value="//Enter Your Code\n>>>objects = fetch(\"(\{handle:'sitting_human'})-[:`CAN_USE`]->(v)\")\n>>>affordance = lambda n:\ fetch(\"{handle :'\" + n + \"'}) - [:`HasAffordance` ] -> (v)\")\n>>>iter = imap(\ lambda u: affordances(u) ,objects)\n>>>iter.next()";
  }
    else if(y[0]=="Filter"){
    document.getElementById("demo").value="//Enter Your Code\n>>>paths = fetch(\"({handle:'sitting_human'})-[e*1..3]->({handle:'cup'})\")\n>>>iter = ifilter(\ lambda u: Belief(u)  > 0.5 ,paths)\n>>>iter.next()";
  }
}

function cleararea()
{
  document.getElementById("demo").value="//Enter Your Code";
}

</script>

<script type="text/javascript">
$('#searchid').blur(function() {
   if($(this).val() != ""){
        $("#drope_box").show();    
    }
    else{
        $("#drope_box").hide(); 
    }
});

 $('#searchid').focus(function() {
    $("#drope_box").show();
 });

</script>



<script type="text/javascript">
  $(document).ready(function() {
    $(".fetch").click(function() {
      $(".panel1").slideToggle("slow");
    });
  });
  $(document).ready(function() {
    $(".sort").click(function() {
      $(".panel2").slideToggle("slow");
    });
  });
 
  $(document).ready(function() {
    $(".map").click(function() {
      $(".panel4").slideToggle("slow");
    });
  });
  $(document).ready(function() {
    $(".filter").click(function() {
      $(".panel5").slideToggle("slow");
    });
  });
  var count;
  $(document).ready(function(){
    $("#demo").click(function(){
   if ($("#demo").val()=="//Enter Your Code"){
        var content="//Enter Your Code\n>>>";
        $("#demo").val(content);
        count = $("#demo").val().length;
      }
    else{
      count=21;
    }
    });
  });
  
//   $(document).keypress(function(e) {
//     if(e.which == 13) {
//         var content=">>>";
//         console.log('hello');
//         var txt = $("textarea#demo");
//         txt.val( txt.val() + "\n>>>");
//         e.preventDefault();
//         count = $("#demo").val().length;
//     }
// });
  var after;
  $(document).keydown(function(e){
    if ( e.keyCode == 8 ){
    after = $("#demo").val().length;
    if(after<count+1)
      e.preventDefault();
    }
});
</script>



 <style type="text/css">
p.fetch,p.sort,p.len,p.map,p.filter{
  margin: 0px;
  padding: 5px;
  background: #eee;
  border: solid 1px #fff;
}
 
div.panel1,div.panel2,div.panel3,div.panel4,div.panel5 {

  display: none;
   margin: 0px;
  padding: 5px;
  border: solid 1px #fff;
}
</style>